# -*- Makefile -*-
# Makefile for source package: kernel
#
# Author: Cristian Gafton <gafton@amazon.com>
#
# Module created by 'gafton' on 2012-01-19

ifeq ($(GIT),)
$(error Makefile.common must be included before this Makefile)
endif

TAREXT		= .tar

ifeq ($(V),)
Q = @
else
Q =
endif

# This is used to generate files for a src.rpm file containing a "vanilla"
# linux kernel archive plus patches. The following defines are needed for this
# to work:
#
# linux_TAGVER
#    the basic version of the kernel, required for tarball names.
# linux_TAR_BASE
#    this defines the tag/commitid which will be used to generate
#    the tarball archive
# linux_PATCH_BASE
#    this defines the tag/commitid used as the floor in the
#    generation of PatchN: and ApplyPatch: lines
# linux_PATCH_HEAD
#    tag/commitid upto which patches are extracted for the PatchN: and
#    ApplyPatch: lines. The linux_PATCH_HEAD can be the name of a branch
#    rooted at linux_TAR_BASE. linux_PATCH_BASE or some other tag/commit-id.
# linux_GIT
#    where to find the git repository of the linux kernel source tree that
#    contains the above tags/branches/commitids

#
# Operation:
#
# * The linux_TAR_BASE is archived and a tarball with TAREXT is created. This
#   is substituted as SOURCE0 in the template file.
# * Every commit between linux_TAR_BASE and linux_PATCH_BASE is generated by
#   git format-patch and then are archived into a tarball which is then
#   replaced as the SOURCE1 in the template kernel spec file.
# * Every commit between linux_PATCH_BASE and linux_PATCH_HEAD are generated
#   as PatchN: and ApplyPatch lines in the template spec file

# Other module-specific defines are:
# *_PREFIX	- the name of the top level directory for the tarball
# *_TAR		- name of the tarball archive filename that will get generated
# *_BRANCH	- default branch that should be checked out

# obtain the proper way to reference a short ref - local or origin
define git_ref
pushd $(CURDIR)/linux >/dev/null ; \
for ref in refs/tags/$(1) refs/heads/$(1) refs/remotes/origin/$(1) ; do \
if $(GIT) show-ref --verify --quiet "$${ref}" ; then echo "$${ref}" ; ref='' ; break ; fi ; \
done ; \
if [ -n "$${ref}" ] ; then echo $(1) ; fi ; \
popd >/dev/null
endef

include linux.vers
# defines for archive building
linux_PREFIX	 ?= linux-$(linux_TAGVER)

linux_TAR_ball	 = linux-$(linux_TAGVER)
linux_PATCH_ball = linux-$(linux_TAGVER)-patches

linux_GIT	= $(shell $(get_fetch_base))/linux.git

# These variables are dereferenced for ease of use
TAR_BASE	= $(shell $(call git_ref,$(linux_TAR_BASE)))
PATCH_BASE	= $(shell $(call git_ref,$(linux_PATCH_BASE)))
PATCH_HEAD	= $(shell $(call git_ref,$(linux_PATCH_HEAD)))

# update the method of computing the buildid
include kernel.vers
define get_build_id
kernel_id=$$($(GIT) describe --long --all --match $(kernel_TAG_BASE) | sed -re 's/^.+-([0-9]+)-[^-]+$$/\1/') ; \
linux_id=$$(cd linux; $(GIT) describe --long --match $(linux_TAR_BASE) $(PATCH_HEAD) | sed -re 's/^.+-([0-9]+)-[^-]+$$/\1/') ; \
echo "$$(($${kernel_id:-0}+1)).$$(($${linux_id:-0}+1))"
endef

# redefine this from Makefile.common to be more kernel specific
define generate-custom-specfile
set -e -x ; \
sed -e "1i%define $(BUILDVAR) $(shell $(get_build_id))\n" <$< >$@ ; \
$(if $(SUBMODULE_SED),sed -i $(SUBMODULE_SED) $@)
endef


tarballs : $(addprefix $(SOURCEDIR)/,$(addsuffix $(TAREXT),$(linux_TAR_ball) $(linux_PATCH_ball)))
sources : tarballs

$(SOURCEDIR)/%.tar.bz2: %.tar | $(SOURCEDIR)
	bzip2 -f -c $< > $@

$(SOURCEDIR)/%.tar.gz: %.tar | $(SOURCEDIR)
	gzip -f -c $< > $@

$(SOURCEDIR)/%.tar : %.tar | $(SOURCEDIR)
	ln -f $< $@

# encapsulate the logic around preparing the linux tree for work
#
# in a lot of cases the linux_BRANCH defines a branch that exists on origin/
# but not on local, so creating a checkout of that branch ensures that the
# branch is valid and it exists. It also allows us to do A..B ranges without
# having to worry whether origin/ needs to be appended or not.
define linux-update
b=$$($(GIT) rev-parse --abbrev-ref HEAD) ; \
if [ "$${b}" != "$(linux_BRANCH)" ] ; then \
  if $(GIT) show-ref --verify --quiet refs/heads/$(linux_BRANCH) ; then \
	$(GIT) checkout $(linux_BRANCH) ; \
  elif $(GIT) show-ref --verify --quiet refs/remotes/origin/$(linux_BRANCH) ; then \
	$(GIT) checkout -t origin/$(linux_BRANCH) ; \
  else \
	echo "ERROR: branch $(linux_BRANCH) seems to be invalid for linux" ; exit -1 ; \
  fi ; \
fi
endef

# extracting source code...
linux :
	$(GIT) clone --no-hardlinks $($@_GIT) $@
linux-update : linux
	$(Q)$(if $(linux_BRANCH), pushd linux >/dev/null; $(linux-update) )

$(linux_TAR_ball).tar : linux-update $(MAKEFILE_LIST) | linux
	$(GIT) archive --format=tar --prefix $(linux_PREFIX)/ --remote=linux $(TAR_BASE) > $@
$(linux_PATCH_ball).tar : linux-update $(MAKEFILE_LIST) | linux
	$(Q)pushd linux >/dev/null ; $(GIT) format-patch -N -k -o $(SOURCEDIR) $(TAR_BASE)..$(PATCH_BASE) | \
	                  xargs -r -l1 basename >$(SOURCEDIR)/$(linux_PATCH_ball).list ; \
	    popd ; \
	tar cf $@ -C $(SOURCEDIR) --remove-files --files-from=$(SOURCEDIR)/$(linux_PATCH_ball).list $(linux_PATCH_ball).list

#
# KERNEL SRC/RPM BUILDING SUPPORT
#
HEADLOG		= $(SOURCEDIR)/head.log
APPLYLOG	= $(SOURCEDIR)/apply.log
PATCHLOG	= $(SOURCEDIR)/patch.log

$(CUSTOMSPEC) : $(HEADLOG)

# extract the top level changelog entry that summarizes the makeup of this build
# $1 : the directory to change to
# $2 : what name to use for this module
# $3..$4 : git commit id range, if any
define get_changelist
{ export TZ=UTC ; \
pushd $(1)>/dev/null ; \
$(GIT) log --date=short --format=tformat:"- $(2)/%H last changes:" $(4) -1 ; \
$(GIT) log --date=short --format=tformat:"  + [%h] [%ad] %s (%ae)" \
	$(if $(3),$(3)..$(4),--since=$$(date +'%Y-%m-%d' --date 'yesterday') -7) \
	$(if $($(2)_LOGS),-- $($(2)_LOGS)) \
	; \
echo ; \
popd >/dev/null ; }
endef

$(HEADLOG): linux-update $(MAKEFILE_LIST) | linux
	$(Q)echo "* $$(TZ=UTC date +'%a %b %d %Y') Builder <builder@amazon.com>" > $@
	$(Q)$(call get_changelist,.,builder,,HEAD) >> $@
	$(Q)$(call get_changelist,linux,linux,$(PATCH_BASE),$(PATCH_HEAD)) >>$@

$(PATCHLOG) : linux-update $(MAKEFILE_LIST) | linux
	$(Q)cd linux ; $(GIT) format-patch -k -o $(SOURCEDIR) -N $(PATCH_BASE)..$(PATCH_HEAD) |\
		xargs -r -l1 basename >$@
	$(Q)sed -i "s/^\(....\)-/Patch\1: \1-/" $@
$(APPLYLOG) : $(PATCHLOG)
	$(Q)sed "s,.*:,ApplyPatch," <$< >$@

clean ::
	$(Q)rm -f$(if $(V),v) $(HEADLOG) $(APPLYLOG) $(PATCHLOG)

# redefine spec file generation to include git logs from submodules
define replace_changelog
$(Q)>.cl.spec
$(Q)>.cl.gitlog
$(Q)>.cl.linux
$(Q)#$(call get_specfile_changelog,$(firstword $(wildcard $(CURDIR)/fedora/kernel.spec) $<)) > .cl.spec
$(Q)#$(call get_gitlog_changelog,$(CHANGELOGS)) > .cl.gitlog
$(Q)pushd linux >/dev/null; $(call get_gitlog_changelog,,$(TAR_BASE),$(PATCH_BASE)) > ../.cl.linux; popd>/dev/null
$(Q)$(find-common-dir)/sort-changelog.py .cl.spec .cl.gitlog .cl.linux > .cl && rm -f .cl.spec .cl.gitlog .cl.linux
$(Q)sed -i -e "/^%changelog/Iq" $@
$(Q)sed -i -e "/^%changelog/ r .cl" $@ && rm -f .cl
$(Q)sed -i -e "/^%changelog/ r $(HEADLOG)" $@ && rm -f $(HEADLOG)
endef

specfile : add-patches | $(CUSTOMSPEC)
add-patches :  $(CUSTOMSPEC) $(APPLYLOG) $(PATCHLOG)
	$(Q)sed -i  -e '/__PATCHFILE_TEMPLATE__/ r $(PATCHLOG)' \
		-e '/__APPLYFILE_TEMPLATE__/ r $(APPLYLOG)' \
		-e 's/__KVERSION__/$(linux_TAGVER)/' \
		$(CUSTOMSPEC)

specfile : update-sources | $(CUSTOMSPEC)
update-sources : $(CUSTOMSPEC) $(MAKEFILE_LIST)
	$(Q)sed -i -r -e "s/^Source0:.*$$/Source0: $(linux_TAR_ball)$(TAREXT)/i" \
		  -e "s/^Source1:.*$$/Source1: $(linux_PATCH_ball)$(TAREXT)/i" $<

# check if the tag exists both in local and remote sites and optionally blow it away
#
# the only way to determine if a tag is set on remote is to delete it locally
# and re-fetch the tags from remote - if it shows up afain as a refs/tags then
# it needs to be deleted both locally and from remote
define check-or-delete-tag
if $(GIT) show-ref --verify --quiet refs/tags/$(1) ; then \
	$(if $(FORCE)$(3),$(GIT) tag -d $(1),echo "ERROR: tag $(1) already exists in `pwd`" ; exit -1 ); \
fi ; \
$(GIT) fetch origin --tags ; \
if $(GIT) show-ref --verify --quiet refs/tags/$(1) ; then \
	$(if $(FORCE)$(3),$(GIT) tag -d $(1); $(GIT) push origin :refs/tags/$(1),\
		echo "ERROR: tag $(1) already exists on remote site" ; exit -1 ); \
fi
endef

# TAG handling and creation
# if linux_TAG is defined, use it.
# if TAG is defined, use it.
# otherwise construct a build/$branch_name/n-v-r tag
linux_TAG	?= $(if $(TAG),$(TAG),build/$(shell $(get_current_branch))/$(shell $(get-spec-nvr)))

# create the tag here
define add-tag
$(call check-or-delete-tag,$(1),$(2)) ; \
git tag $(1) $(if $(2),$(2),HEAD)
endef

tag : linux-update | linux
	$(call add-tag,$(linux_TAG))
	pushd linux >/dev/null ; $(call add-tag,$(linux_TAG),$(PATCH_HEAD)) ; popd >/dev/null
force-tag :
	$(MAKE) tag FORCE=1
delete-tag : | linux
	$(call check-or-delete-tag,$(linux_TAG),,delete)
	pushd linux >/dev/null ; $(call check-or-delete-tag,$(linux_TAG),,delete) ; popd >/dev/null

git-push : git-push-linux

git-push-linux : linux
	pushd linux ; $(GIT) push origin $(linux_BRANCH):refs/heads/$(linux_BRANCH) ; $(GIT) push origin --tags ; popd

clean ::
	$(Q)rm -f$(if $(V),v) linux.tar $(linux_TAR) *$(TAREXT)
	$(Q)rm -f$(if $(V),v) $(SOURCEDIR)/$(linux_TAR_ball).tar $(SOURCEDIR)/$(linux_PATCH_ball).tar

.SECONDARY : $(linux_TAR)

.PHONY:

